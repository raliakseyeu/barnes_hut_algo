import grav_sim as g
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.animation import FuncAnimation

def plot_tree (tree, particles, fig, ax):
    """
    Plot the tree (and its particles) generated by grav_sim, given fig, ax
    """
    # plot particles 
    pos = np.array([p.position for p in particles])
    x = pos[:, 0]
    y = pos[:, 1]
    plt.scatter(x, y, c="k", marker=".", s=10)

    # the reason we can't store this information in the tree even though we 
    # had to compute for the tree construction is that the tree will be kept
    # in memory during simulation, and we don't need to store the cell dimensions
    # in the tree structure for the simulation to work
    positions = np.array([p.position for p in particles])
    min_x = np.amin(positions[:, 0])
    min_y = np.amin(positions[:, 1])
    max_x = np.amax(positions[:, 0])
    max_y = np.amax(positions[:, 1])
    square_side = max(max_x - min_x, max_y - min_y)
    lower_left = np.array([min_x, min_y]) 

    _plot(tree, lower_left, square_side, fig, ax)

    plt.show()

def _plot (tree, ll, side, fig, ax):
    """
    Recursive helper method for the plot_tree function
    """
    # plot this square if it non-zero mass
    if tree.mass > 0:
        rect = patches.Rectangle(ll, side, side, linewidth=1, 
                                edgecolor='r', facecolor='none')
        ax.add_patch(rect)

    if tree.children:
        # subdivide this square
        half_side = side / 2
        x, y = ll
        ll_1 = [x + half_side, y + half_side]
        ll_2 = [x, y + half_side]
        ll_3 = [x, y]
        ll_4 = [x + half_side, y]
        lls = [ll_1, ll_2, ll_3, ll_4]

        for i in range(4):
            _plot(tree.children[i], lls[i], half_side, fig, ax)


def animate_simulation(filepath, ll = None, ur = None, result_fps = 24):
    """
    Animate simulation using pre-computed data, save the result
    ll and ur specify bounding box
    """
    file = open(filepath, "r")
    datalines = file.readlines()

    # process the data
    ticks = []
    curr_tick = []
    for line in datalines:
        if line == "#\n":
            ticks.append(curr_tick)
            curr_tick = []
        else:
            data_li = line[:-1].split()
            position = np.array([float(data_li[0]), float(data_li[1])])
            curr_tick.append(position)

    # convert ticks and the lists within it to numpy arrays for plotting
    ticks = np.array([np.array(tick) for tick in ticks])

    fig = plt.figure()
    ax = plt.axes(xlim=(ll[0], ur[0]), ylim=(ll[1], ur[1]))

    def update(i):
        ax.clear()
        ax.set_facecolor('k')
        plt.scatter(ticks[i][:, 0], ticks[i][:, 1], c="w", marker=".", s=10)
        ax.set_xlim([ll[0], ur[0]])
        ax.set_ylim([ll[1], ur[1]])

    ani = FuncAnimation(fig, update, interval=int(1000/result_fps))
    filename = filepath.split("/")[-1] # last thing in the file address
    file_no_ext = filename.split(".")[0] # remove extension
    ani.save("../visualizations/"+file_no_ext+".gif", fps=result_fps)
